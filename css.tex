\documentclass{acm_proc_article-sp}

\begin{document}

\title{Protecting Browsers from Cross-Origin CSS Attacks}

\numberofauthors{3}
\author{
\alignauthor
Chris Evans\\
      \affaddr{Google}\\
      \affaddr{cevans@google.com}
\alignauthor
Lin-Shung Huang\\
      \affaddr{Carnegie Mellon University}\\
      \affaddr{linshung.huang@sv.cmu.edu}
\alignauthor
Collin Jackson\\
      \affaddr{Carnegie Mellon University}\\
      \affaddr{collin.jackson@sv.cmu.edu}
}

\maketitle
\begin{abstract}
The cross-origin CSS attack is a newly exploited browser vulnerability that allows the attacker to steal the user's secret content on an honest web site from a different domain. In this paper, we expose the cross-origin CSS attack, in which the attacker injects CSS strings into the target domain that contains the secret content, instructs the user's browser to import and parse the document as a style sheet, and then exports the secret string hidden in the imported style sheet to the attacker. This attack is constructed upon the lenient requirement of content type and lax parsing of CSS in modern browsers. We detail existing client-side and server-side mitigation techniques and find shortcomings with each technique. We propose that browsers implement a stricter CSS parsing for cross-origin loads when the content type is broken, which can provide robust defense for cross-origin CSS attacks while addressing web site compatibility concerns.
\end{abstract}

\category{K.6.5}{Management of Computing and Information Systems}{Security and Protection}

\terms{Security}

\keywords{Content-Sniffing, CSS, Same-Origin Policy}

\section{Introduction}
(This is the introduction.)

browser quirks/strict modes

Content sniffing XSS\cite{securecontentsniffing}

JavaScript hijacking\cite{jshijacking}

\section{Threat Model}
We define a precise threat model, the web attacker, for reasoning the cross-origin CSS attack. We assume that the attacker's goal is to steal the user's secret content on an honest web site from another domain.

\subsection{Web Attacker (or Data Theft?)}
A web attacker is a malicious principal who owns a domain name, e.g. attacker.com, and operates a web server. To study the browser's defense mechanisms, we assume that the user's browser renders content from the attacker's web site. In addition, the web attacker is given the ability to inject arbitrary strings into the target domain.

\begin{itemize}

\item{Attacker Abilities:}
The web attacker can send and receive network messages over network protocols of the attacker's choice, but only from its own machines. Typically, the web attacker operates at least one machine as an HTTP server, which we refer to as attacker.com. The web attacker has no control over the user's network connections. In particular, the web attacker cannot eavesdrop on unencrypted connections and steal session identifiers to hijack the user's session. Neither can the web attacker spoof network frames and impersonate the user to an honest web site.

\item{User Behavior:}
We assume that the user visits the attacker's web site with a popular browser. In practice, this assumption can be supported by several techniques for attacking users, e.g. buying web advertisements or sending bulk e-mail to encourage visitors. By visiting attacker.com, the attacker can instruct the user's browser to fetch external style sheets and also export data to remote servers. As long as the user's session with an honest web site haven't expired, the attacker can instruct the user's browser to issue requests with the user's cookies.

\item{Web Site Behavior:}
We assume that the attacker can inject semi-arbitrary strings into a target domain that contains the secret content, which we refer to as victim.com. We define the term semi-arbitrary strings as a subset of strings that may conform to CSS syntax as opposed to fully arbitrary strings that conforms to HTML. The ability of injecting CSS strings is considered weaker than injecting HTML strings into the target domain, as in common XSS attacks, because scripts may be detected and blocked by client-side XSS filters. In practice, there are various methods to inject strings into the target domain, e.g. reflection of user controlled strings or via URL parameters.

\end{itemize}

There are a number of related threats that we do not consider in this paper, such as phishing, DNS rebinding, and XSS.
(more description...?)
The web attacker is incapable of installing malicious software on the user's machine, otherwise, the malware could replace the browser and bypass any browser-based defenses.

\section{Attacks}
In this section, we study cross-origin CSS attacks. First, we provide some background information. Next, we introduce cross-origin CSS attacks. Then, we discuss the restrictions for constructing this attack and suggest general areas that are exploitable. Finally, we demonstrate an attack against a popular web site as our proof of concept.

\subsection{Background}
In this section, we provide background information about Cascading Style Sheets (CSS), the same-origin policy (SOP), and content sniffing.

\subsubsection{Cascading Style Sheets}
Cascading Style Sheets\cite{css} is a mechanism that lets web developers control the visual appearance of web documents using style sheet language. The design of CSS enables separation of document content from the visual appearance, including layouts, colors, and fonts. This allows web sites to adjusting its appearance, e.g. switching on-screen views to printable views, without requiring modifications to the document. Furthermore, documents are allowed to import external style sheets and let third parties to control a subset of the CSS rules. This feature allows web sites to share style sheets across a number of documents.

\paragraph{Lax Parsing}
In modern browsers, the CSS parser is actually very lax. The CSS parser will skip over any amount of invalid syntax in the style sheet until it finds the next valid rule. This is unlike the JavaScript parser that will abort on the first syntax error. A lax CSS parser gives the browser better compatibility for supporting misconfigured web sites, but unfortunately opens opportunities to attackers and enables the cross-origin CSS attack in this paper.

(Chris: I think they are intending to be forward-compatible with brand new CSS syntax too.
There is some small interpretation of invalid syntax: careful track seems to be kept regarding opened brackets. I think this includes { ( and [ -- but of course may be browser dependent. Any CSS injection point may have to close an arbitrary number of these brackets: of the correct type in the correct order!)

\subsubsection{Same-Origin Policy}
The same-origin policy\cite{mozillasameorigin} is the main security mechanism in modern browsers that provides isolation of contents between unrelated web sites. The same-origin policy restricts contents to access resources only from the same origin, which applies to scripting interactions, i.e. XMLHttpRequest and Document Object Model (DOM)\cite{dom} access. In SOP, the origin of a resource is defined as the protocol, host, and port. The same-origin policy does not apply to fetching and executing remote libraries, including scripts and style sheets, from a different origin.

\subsubsection{Content-Sniffing}
The HTTP Content-Type header indicates the type of the content that is transmitted using Multipurpose Internet Mail Extensions (MIME)\cite{mime} types such as text/plain for plain text and image/jpeg for JPEG images. The line in the HTTP header typically looks like the following:
\begin{verbatim}
Content-Type: text/html; charset=utf-8
\end{verbatim}
Browsers use MIME types to determine how to handle the contents of HTTP responses. However, many misconfigured web servers fail to provide the correct MIME type of their resources. Due to web site compatibility concerns, modern browsers use content-sniffing algorithms\cite{securecontentsniffing} to guess the correct MIME type by inspecting the contents of HTTP responses.  Content-sniffing algorithms can override the provided MIME type and file extension of the document. Unfortunately, this quirk introduces chameleon documents, in which a document conforms to its original file format (such as PDF) while containing malicious HTML.

\subsection{Cross-Origin CSS Attack}
In a cross-origin CSS attack, the attacker's main objective is to steal the user's secret content on an honest web site from a different domain. The attacker is most likely interested in stealing any sensitive information in a cookie-authenticated web page, or preferably a secret CSRF token\cite{csrf} hidden in the document that may allow the attacker to hijack the user's session. In order to steal content from a different domain, the attacker leverages the fact that the browser's security policy allows external style sheets to be imported from cross-origin. The target document on an honest web site is injected such that portions of the document conform to CSS rules. As soon as the user visits the attacker's malicious page, the cross-origin data is imported as style sheets and stolen. To describe the cross-origin CSS attack in detail, we decompose the attack into three main steps: CSS string injection, style sheet import, and data export.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{scenario.jpg}
\caption{Attack Scenario}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\linewidth]{steps.jpg}
\caption{Three Steps of the Attack}
\end{figure}

\subsubsection{CSS String Injection}
Due to lenient MIME type requirement of CSS parsers, the attacker may fool the user's browser into loading a carefully crafted non-CSS (e.g. HTML or XML) document as a valid style sheet resource. In practice, there are several methods that may allow a web attacker to inject strings into the target domain, e.g. reflection of user controlled strings or via URL parameters. Normally, random text in a non-CSS document contains syntax errors to the CSS parser and would break the parsing. However, due to the overly lax CSS parsers in modern browsers, portions of a non-CSS document with valid CSS syntax can still be successfully parsed and recognized as style sheet rules.

To give an example of a CSS string injection, suppose that there is s sensitive content, represented with the string `SECRET', in an HTML document on an honest web site that the attacker wants to steal. Assuming that the attacker has sufficient influence over the web page to control the text preceding and succeeding the secret string, the CSS string injection can be constructed based on common CSS properties that corresponds to string values, i.e. font-family, background-image, and list-style-image. Given the ability to inject arbitrary strings into the target domain, the HTML document can be crafted to contain a CSS font-family property as the following:
\begin{verbatim}
Original:
<HTML>..SECRET..</HTML>

After injection:
<HTML>..{} BODY { font-family: "SECRET" }..</HTML>
\end{verbatim}
The injected HTML document will appear to the CSS parser as containing a valid CSS rule. The fonts of the attacker's page will be styled with a font-family specified as the stolen string `SECRET'. Note that the seemingly redundant pair of brackets in the injection string re-syncs the CSS parser to make sure that the evil CSS rule parses properly. All the other non-CSS text in the document are skipped by the CSS parser, thus will not effect the user's browser parsing of the evil CSS rule. Once the crafted document is loaded, the attacker can easily steal the secret string from the font-family style of the attacker's page.

\subsubsection{Style Sheet Import}
When the user visits attacker.com, the attacker's malicious page instructs the user's browser to fetch and load the crafted document as a style sheet. In HTML specifications\cite{html}, documents can import external style sheets from remote servers by using the CSS '@import' notation, or using the link tag inside the head element as the following: .
\begin{verbatim}
<HTML>
<HEAD>
  <STYLE>
    @import url(http://victim.com);
  </STYLE>
  <LINK REL="stylesheet" HREF="http://victim.com">
</HEAD>
</HTML>
\end{verbatim}
\paragraph{Cookies}
According to the standards, the browser always sends the user's cookie when it loads any referenced style sheets, including cross-origin. If the user was logged into the victim.com while visiting the malicious page, the browser would send the user's authentication cookie on all requests to victim.com and be considered as valid authenticated requests. This behavior exploits cookie-authenticated web sites and potentially leaks the user's sensitive information in the server's response. 

\subsubsection{Data Export}
The final step for the attacker is to read the loaded style sheets and export the secret content hidden in the style properties to the attacker. There are various methods to export data to other origins, in this specific attack we are interested in approaches where no user involvement is required. The cross-origin CSS attack is possible by just rendering one evil ad in the user's browser. 

\paragraph{JavaScript}
One method is using JavaScript to access the loaded styles and then send the stolen data to attacker.com using the XMLHttpRequest API. All major browsers support reading styles in JavaScript, e.g. through DOM access by calling the window.getComputedStyle method, or retrieving the currentStyle object in Internet Explorer. WebKit-based browsers, i.e. Safari and Google Chrome, even surrendered the full CSS text of style sheets, including CSS rules loaded from cross-origin (without comments, thankfully). The attacker could read the raw text of cross-origin CSS via document.styleSheets[].cssRules[].cssText and also window.getMatchedCSSRules().cssText. This behavior violates the same-origin policy and potentially leaks data in pages with semi-valid CSS constructs. Other browsers only permit read access for raw CSS text under restricted conditions. Internet Explorer allows access to cross-origin CSS raw text with document.styleSheets[].rules[].style.cssText only if the MIME type is correct. Firefox and Opera only allows access to CSS raw text for style sheets loaded from same-origin.
Even if access to raw CSS text is blocked, the ability to read cross-origin loaded CSS styles is enough to construct serious attacks.

%raw CSS text without comments, thankfully
%Some browsers (Chrome and Opera) cautiously block DOM access to styles loaded from cross-origin unless the CSS is well-formed. Other browsers (Internet Explorer, Firefox and Safari) still grant read access to the styles loaded from cross-origin CSS.  Chrome and Opera allows access to cross-origin CSS raw text with document.styleSheets[].rules[] only if the external file is well-formed. Chrome also allows access to cross-origin CSS raw text with window.getMatchedCSSRules() if the external file is well-formed.

\begin{table}
\centering
\caption{Cross-Origin CSS DOM Vulnerability}
\begin{tabular}{|c|c|c|c|c|c|} \hline
Methods&IE&FF&OP&Safari&Chrome\\ \hline
currentStyle&v&&v&&\\ \hline
getComputedStyle&&v&v&v&v\\ \hline
rules[].style.cssText&v&&&v&v\\ \hline
cssRules[].cssText&&&&v&v\\
\hline\end{tabular}
\end{table}

\paragraph{Background-image}
Another method is available to exploit users that have disabled JavaScript in their browsers by simply injecting the CSS background-image string as the following:
\begin{verbatim}
<HTML>..{} BODY { background-image: url(http://att
acker.com/?SECRET); }..</HTML>
\end{verbatim}
Using this method, the secret string is appended to the path or query string of the attacker's server URL. Therefore, the background of the attacker's page will be styled with a background image loaded from an URL, the path of which contains stolen data. One important characteristic of the CSS property background-image, which is an URL, is that it will be automatically fetched even if JavaScript is turned off. The stolen data is then harvested by the attacker from their web server logs.

\subsection{General Restrictions}
The cross-origin CSS attack is less serious than it could be, because there are a few restrictions of cross-origin data which can be stolen.

\subsubsection{Sufficient Injection Points}
The first and most crucial step of the cross-origin CSS attack is to contain the secret data into a CSS property string. In order for the CSS parser to properly parse the evil CSS rule, certain symbols must be inserted at the beginning and at the end of the stolen string. In general, the attacker must have sufficient influence over the target document to control two injection points, pre-string and post-string, to insert the starting symbols and termination symbols, respectively. Typically, socially-related web sites are relatively more susceptible to this attack since the pages often contain user-controlled strings such as comments on photos. For some web sites, a second injection is not required because the termination symbols happens to exist later in the document. This is possible since the termination symbols can be as short as just a quotation mark and an ending bracket. 

\subsubsection{Avoid Character Escapes}
In CSS specifications\cite{css}, strings can either be written with double quotes or with single quotes. Double quotes cannot occur inside double quotes, analogously for single quotes. Therefore, the attacker has the choice to inject either single or double quotes depending on the occurrence of quotes in the secret data. In a context where both quotes are escaped, it becomes more difficult to inject a CSS string. However, a variation of the attack  can bypass this restriction by injecting the background-image property. For the background-image property, the URL value is written with the functional notation url(), which does not require the use of single or double quotes around the URL string itself. The CSS specification does define that certain characters must be escaped in an unquoted URL, e.g. parentheses, commas, white spaces, single quotes and double quotes. However, in Internet Explorer, the CSS parser does not require any of these characters to be escaped in an unquoted URL and will parse until it encounters a closing parentheses and a semicolon.

\paragraph{Force UTF-7}
The requirement for quotes to not get escaped can sometimes be bypassed in browsers that support UTF-7 encoding, including Firefox and Safari. If the victim web sites fails to specify a character set in the HTTP  Content-Type header, the attacker's malicious page can force the remote resource to be parsed as UTF-7 encoding as the following:
\begin{verbatim}
<LINK REL="stylesheet" HREF="http://victim.com" 
CHARSET="utf-7">
\end{verbatim}
By forcing UTF7, either a single or double quote may be injected by rendering it in the UTF-7 character set, i.e. `+ACc-' for single quote and `+ACI-' for double quote. This will cause the injection to survive any output escaping of the web application. A significant number of web sites actually do not specify character sets in their HTTP responses (We found that 22 out of the top 100 web sites via Alexa\cite{alexa} did not specify character sets). Some web sites specify the Content-Type information using meta tags with the http-equiv attribute in the HTML head element as the following:
\begin{verbatim}
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; 
charset=utf-8">
\end{verbatim}
Browsers may use meta tags to refine the information provided by the actual headers, but can also ignore it. Thus, using the equivalent HTTP header to specify the MIME type and character set is recommended for security reasons.

\subsubsection{Avoid Newlines}
In CSS, a string cannot directly contain a newline. To include a newline in a string, the line feed character must be escaped. Therefore, another barrier of this attack is that any un-escaped newline in the stolen string will break the CSS parsing. This is a very common condition in many web pages, which avoids potentially serious attacks. However, many rich-functionality web sites are often exploitable due to serving subtle cookie-authenticated URLs with JSON or XML responses that commonly lack newlines. Some web sites even allow users to control the formatting of server responses, e.g. disable pretty printing, which may be extremely dangerous.
\paragraph{Internet Explorer}
Catastrophically, the CSS parser in the Internet Explorer accepts both newlines in CSS strings and newlines in unquoted URL strings, regardless of whether escaped or not. Unfortunately, even a fully-patched browser can expose its users to a cross-origin CSS data theft and potentially serious session hijacking.

\subsection{Concrete Attacks}
?? mixi.jp post\_key theft\cite{cssxss}

Example: Yahoo! Mail

\section{Defenses}
In this section, we describe the defenses against cross-orgin CSS attacks. First, we propose modifying browsers to stricten CSS loading. Second, we present an evaluation of web site compatibility for our proposal. Then, we state the progress of adoption for our proposal in major browsers. Finally, we discuss the shortcomings of other approaches including client-side and server-side mitigations.

\subsection{Proposal: Stricter CSS Loading}
To prevent cross-origin CSS attacks, we propose modifying browsers to apply stricter CSS loading for cross-origin references. The initial approach is to enforce strict MIME type checking for CSS loads. We also provide a conservative approach that maximizes web site compatibility while blocking most attacks.

\subsubsection{Strict MIME Type}
In the cross-origin CSS attack, the attacker's malicious web page confuses the user's browser to parse an injected non-CSS document as a style sheet. If browsers strictly required external style sheets to specify a valid MIME type, which is text/css, the malicious web page would not be able to reference any crafted document. Thus, we propose that browsers always check the MIME type of external CSS references and block any CSS load with an invalid MIME type. When strict MIME type checking is enforced, if not globally at least for cross-origin loads, browsers would be able to prevent cross-origin data from being stolen. 

A major concern of strict MIME type checking is that any misconfigured web site that fail to provide valid MIME types would be blocked. Strict MIME type checking relies on web developers to correctly deploy their web sites and provide valid MIME types. Unless every web developer correctly configures the served MIME type, this approach will inevitably detect false positives and cause web site breakage. Unsurprisingly, browser vendors would tend to resist changes that would cause web site breakage and lose its users.

The Internet Explorer's proposal of the X-Content-Type-Options header \cite{nosniff} allows opting out of MIME sniffing by specifying the nosniff directive in the HTTP response header. For browsers that support this feature, web developers can configure their servers to specify the nosniff directive and defend against chameleon documents. However, the nosniff directive does not trigger strict MIME type checking for style sheets.

\subsubsection{Conservative Approach}
To address web site compatibility concerns, we propose a conservative approach that blocks most attacks while tolerating MIME type misconfiguration. In order to reduce false positives in the strict MIME type approach, an additional level of checking is applied to cross-origin CSS loads that have invalid MIME types. When a valid MIME type is not provided, the browser will try to parse the cross-origin CSS but bailing on first syntax error. This sniffing mechanism is to guess whether the imported CSS file is actually an injected victim document. Therefore, the devised solution blocks a CSS load when all the following conditions are met:
\begin{itemize}
\item{The CSS load is a cross-origin.}
\item{The CSS load has an invalid MIME type. Valid MIME types are text/css, application/x-unknown-content-type, and empty.}
\item{The alleged CSS does not start with a syntactically valid CSS construct.}
\end{itemize}
The above rules will block the attack because non-CSS documents always have headers, e.g. HTML or XML header, that will cause a broken first CSS descriptor. We assume that an untampered CSS file will unlikely have a syntax error at the beginning of the file. Only a cross-origin CSS with invalid MIME type that starts with malformed syntax is considered as an injected document and rejected.

\subsubsection{Experiment}
To evaluate the compatibility of strict MIME type checking, we conducted an experiment to measure how often web sites fail to provide a valid MIME type for cross-origin CSS files.

We ran a scan across the top 500,000 URLs looking for cross-origin loads of CSS with an invalid MIME type. Valid MIME types are defined as text/css, application/x-unknown-content-type, and empty. There were a total of 140 URLs detected that referenced cross-origin CSS with broken MIME types. We found that some of them were non-serious conditions, in which the site loaded a CSS file which is missing and redirected to a 404 html page. There were 60 URLs that would be considered as broken, including 13 with text/plain, 15 with text/html, 31 with application/css, and 1 with application/x-pointplus.

(more details..)

(stats other MIME?: application/octet-stream, application/x-unknown-content-type, empty)

Due to practical limitations, all of the tested links were unauthenticated. It is possible that more sites will be broken after logging in. Although only 0.012\% of the URLs were broken, if any popular web site crashed due to stricter CSS loading, browser vendors would possibly resist to deploy this change in risk of losing its users. Most prominently, configure.dell.com was loading cross-origin CSS with text/plain MIME type, but it was well formed CSS.

If we apply the heuristics of the conservative approach, only one URL that served text/html MIME would fail to load, which was severely broken because it had valid CSS rules after a <style> tag.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{mime.jpg}
\caption{Invalid MIME Types for Cross-Origin CSS}
\end{figure}

\subsubsection{Adoption}
The conservative approach of stricter CSS loading was implemented in a patch to WebKit, an open source component of Safari and Google Chrome. The WebKit patch was first deployed in Google Chrome 4.0.249.78, and also accepted in Safari 4.0.5. Inspired by our WebKit patch, the exact same heuristic was deployed in Opera 10.10.

Mozilla proposes to deploy strict MIME type checking in Firefox 3.6 (version undetermined).

\subsection{Other Approaches}

\subsubsection{Client-side Defenses}
\paragraph{Disable Cookies:}
Prevent sending cookies when importing cross-origin CSS;
login status check;

\paragraph{Restrict DOM Access:}
DOM same-origin policy;
background-image bypass

\paragraph{Strict CSS Parsing:}
Strict CSS parsing;
crash hard on error;

\subsubsection{Server-side Mitigations}
Blah
only GET
<link> tag always uses HTTP GET requests to load style sheets from external sources

\paragraph{Newlines}
Newlines;
\paragraph{Escaping Quotes}
Escaping quotes;

\paragraph{Don't Use Cookies}
Sending session cookies enables web sites to provide user-specific styles by controlling the response of each uer's request.
adjust to mobile account, printable view..;
capabilities? web key


\section{Related Work}

\subsection{Secure Content Sniffing}
secure content sniffing\cite{securecontentsniffing}

\subsection{JavaScript Hijacking Defenses}
JavaScript hijacking\cite{jshijacking}

\subsection{Gazelle}
gazelle\cite{gazelle}
strict mode

\section{Conclusions}
(This is the conclusion.)

\bibliographystyle{abbrv}
\bibliography{css}

\end{document}
